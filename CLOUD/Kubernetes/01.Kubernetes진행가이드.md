[Dstone Document Index](../../Index.md)

# Kubernetes 클러스터 구축 가이드

이 문서는 VirtualBox와 Ubuntu 20.04를 사용하여 Kubernetes 클러스터(Master 1대, Worker 2대)를 구축하는 과정을 안내합니다.

---

## 1. 가상 환경 구성 (VirtualBox)

### 1.1. 사전 준비

-   **VirtualBox 설치**: [공식 사이트](https://www.virtualbox.org/wiki/Downloads)에서 최신 버전을 설치합니다.
-   **Ubuntu 20.04 ISO**: Ubuntu 20.04 LTS 데스크탑 이미지를 다운로드합니다.
-   **Hyper-V 설정 확인** : Windows에서 Hyper-V가 활성화되어 있는지 확인합니다.
    ```powershell
    bcdedit /enum | findstr /i hypervisorlaunchtype
    ```
-   **Hyper-V 비활성화**: 만약 결과가 `Off`가 아니라면, VirtualBox는 Windows의 Hyper-V와 충돌할 수 있습니다. 관리자 권한으로 다음 명령을 실행하여 비활성화합니다.
    ```powershell
    bcdedit /set hypervisorlaunchtype off
    ```
    > **참고:** WSL2나 Docker Desktop을 다시 사용하려면 `auto`로 재설정해야 합니다 (`bcdedit /set hypervisorlaunchtype auto`).

### 1.2. 가상 머신(VM) 생성

-   **Master Node**: `k8s-master` 이름으로 VM 생성
-   **Worker Node 1**: `k8s-node1` 이름으로 VM 생성
-   **Worker Node 2**: `k8s-node2` 이름으로 VM 생성

### 1.3. 네트워크 설정

1.  **NAT 네트워크 생성**
    -   VirtualBox `파일 > 도구 > 네트워크 관리자`에서 `만들기`를 클릭하여 NAT 네트워크를 생성합니다.
    -   네트워크 이름: `k8s-network`
    -   네트워크 CIDR: `10.100.0.0/16`

2.  **VM 네트워크 어댑터 설정**
    -   생성한 모든 VM(master, node1, node2)의 `설정 > 네트워크`에서 '다음에 연결됨'을 `NAT 네트워크`로 변경하고, 네트워크 이름으로 `k8s-network`를 선택합니다.

3.  **포트 포워딩 설정**
    -   `NAT 네트워크` 설정 화면의 `포트 포워딩` 버튼을 클릭하여 각 VM에 SSH로 접속할 수 있도록 규칙을 추가합니다.

| 이름        | 프로토콜 | 호스트 IP | 호스트 포트 | 게스트 IP      | 게스트 포트 |
| :---------- | :------- | :-------- | :---------- | :------------- | :---------- |
| k8s-master  | TCP      | 127.0.0.1 | 2200        | 10.100.0.100   | 22          |
| k8s-node1   | TCP      | 127.0.0.1 | 2201        | 10.100.0.101   | 22          |
| k8s-node2   | TCP      | 127.0.0.1 | 2202        | 10.100.0.102   | 22          |

---

## 2. 모든 노드 공통 설정

이제 각 VM에 접속하여 아래 설정을 **master, node1, node2에 모두 적용**합니다.

### 2.1. 호스트 이름 및 `hosts` 파일 설정

-   **/etc/hostname** 수정: 각 노드의 호스트 이름을 설정합니다.
    -   `k8s-master` 노드: `master`
    -   `k8s-node1` 노드: `node1`
    -   `k8s-node2` 노드: `node2`

-   **/etc/hosts** 수정: 모든 노드가 서로의 IP와 호스트 이름을 알 수 있도록 설정합니다.
    ```
    127.0.0.1       localhost
    10.100.0.100    master
    10.100.0.101    node1
    10.100.0.102    node2
    ```

### 2.2. 고정 IP 설정

-   `/etc/netplan/01-network-manager-all.yaml` 파일을 수정하여 고정 IP를 설정합니다. (파일명은 다를 수 있음)

    ```yaml
    network:
      version: 2
      renderer: NetworkManager
      ethernets:
        enp0s3: # 네트워크 인터페이스 이름 (ifconfig로 확인)
          dhcp4: no
          addresses:
            # master: [10.100.0.100/16]
            # node1: [10.100.0.101/16]
            # node2: [10.100.0.102/16]
            - 10.100.0.100/16
          routes:
            - to: default
              via: 10.100.0.1
          nameservers:
            addresses: [8.8.8.8, 8.8.4.4]
    ```

-   설정 적용
    ```bash
    sudo netplan apply
    ```

### 2.3. Kubernetes 사전 요구사항 설정

1.  **Swap 비활성화**
    ```bash
    sudo swapoff -a
    # 재부팅 후에도 적용되도록 /etc/fstab 파일에서 swap 라인을 주석 처리
    sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
    ```

2.  **필요 커널 모듈 로드**
    ```bash
    cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
    overlay
    br_netfilter
    EOF

    sudo modprobe overlay
    sudo modprobe br_netfilter
    ```

3.  **네트워크 브리지 설정**
    ```bash
    cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
    net.bridge.bridge-nf-call-iptables  = 1
    net.bridge.bridge-nf-call-ip6tables = 1
    net.ipv4.ip_forward                 = 1
    EOF

    # 변경사항 적용
    sudo sysctl --system
    ```

### 2.4. Docker 설치 (컨테이너 런타임)

Kubernetes는 컨테이너를 실행하기 위해 Docker와 같은 컨테이너 런타임이 필요합니다.

```bash
# 1. HTTPS 통신을 위한 패키지 설치
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl

# 2. Docker 공식 GPG 키 추가
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# 3. Docker 저장소 설정
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# 4. Docker Engine 설치
sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io

# 5. Cgroup 드라이버 설정
# containerd의 기본 설정 파일을 생성하고, SystemdCgroup을 true로 변경합니다.
sudo containerd config default | sudo tee /etc/containerd/config.toml
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml

# 6. 서비스 재시작
sudo systemctl restart containerd
sudo systemctl enable docker
```

### 2.5. Kubernetes 구성 요소 설치

`kubeadm`, `kubelet`, `kubectl`을 설치합니다.

```bash
# 1. apt 패키지 색인을 업데이트하고 HTTPS를 통해 저장소를 사용하는 데 필요한 패키지를 설치
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl gpg

# 2. Kubernetes 패키지 저장소의 공개 서명 키를 다운로드
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

# 3. Kubernetes apt 저장소를 추가
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

# 4. apt 패키지 색인을 업데이트하고 kubelet, kubeadm, kubectl을 설치하고 해당 버전을 고정
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl # 자동 업데이트 방지
```

### 2.6. Sftp 설치

---

## 3. Master Node 설정

**master 노드에서만** 다음 명령을 실행합니다.

### 3.1. 클러스터 초기화

```bash
# --pod-network-cidr: 파드 네트워크의 IP 주소 범위. Calico, Flannel 등 CNI 플러그인과 일치해야 함.
sudo kubeadm init --pod-network-cidr=10.244.0.0/16
```

### 3.2. kubectl 설정

-   초기화가 성공하면 출력되는 안내에 따라 `kubectl`을 설정합니다.
    ```bash
    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config
    ```

### 3.3. CNI(Container Network Interface) 플러그인 설치

-   파드 간의 통신을 위해 CNI 플러그인을 설치해야 합니다. 여기서는 **Flannel**을 사용합니다.
    ```bash
    kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
    ```

### 3.4. 클러스터 상태 확인

```bash
kubectl get nodes
# Master 노드가 'Ready' 상태로 표시되는지 확인합니다.
```

---

## 4. Worker Node 설정

**node1, node2에서 각각** 다음 명령을 실행합니다.

### 4.1. 클러스터에 조인

-   Master 노드에서 `kubeadm init` 실행 시 출력되었던 `kubeadm join` 명령어를 복사하여 실행합니다.
    ```bash
    sudo kubeadm join <master-ip>:6443 --token <token> --discovery-token-ca-cert-hash sha256:<hash>
    ```
-   만약 토큰을 잃어버렸다면, Master 노드에서 다음 명령으로 재생성할 수 있습니다.
    ```bash
    kubeadm token create --print-join-command
    ```

### 4.2. 조인 확인

-   다시 **Master 노드에서** `kubectl get nodes`를 실행하여 모든 Worker 노드가 `Ready` 상태가 되는지 확인합니다. (몇 분 정도 소요될 수 있습니다.)
    ```bash
    kubectl get nodes -o wide
    # NAME     STATUS   ROLES           AGE   VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME
    # master   Ready    control-plane   10m   v1.28.0   10.100.0.100   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   containerd://1.6.12
    # node1    Ready    <none>          2m    v1.28.0   10.100.0.101   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   containerd://1.6.12
    # node2    Ready    <none>          2m    v1.28.0   10.100.0.102   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   containerd://1.6.12
    ```

---

## 5. Kubernetes의 주요 Unit(객체)

### 5.1 전체 구조 한 눈에 보기 (상관관계)

```
[Cluster]
 ├─ [Node : 물리적 묶음]
 │    ├─ Pod
 │    │    ├─ Container
 │    │    └─ Container
 │    └─ Pod
 │
 ├─ [Namespace : 논리적 묶음]
 │    ├─ Deployment(Pod 관리자)
 │    │    └─ ReplicaSet
 │    │         └─ Pod
 │    ├─ Service
 │    │    └─ Label Selector
 │    │         └─ Pod
 │    ├─ ConfigMap
 │    │    └─ Pod
 │    └─ Secret  
 │         └─ Pod
 └─ [Control Plane : Unit들을 관리하는 API]
      ├─ API Server
      ├─ Scheduler
      └─ Controller Manager
```

- Cluster
```text
 1. 정의
   - 쿠버네티스 전체 환경의 최상위 개념
 2. 역할
   - 컨테이너 오케스트레이션
   - API 제공, 스케줄링, 상태 관리
```
   
- Cluster > Node
```text
 1. 정의
   - Pod가 실제로 실행되는 물리 서버 또는 VM
   - 실행 인프라 단위
 2. 구성 요소
   - kubelet(Pod 실행 관리)
   - container runtime (docker, containerd)
   - kube-proxy(네트워크)
 3. 특징
   - 하나의 Node에 여러 Pod 실행 가능
   - Scheduler가 Pod를 Node에 배치
```
   
- Cluster > Node > Pod
```text
 1. 정의
   - 쿠버네티스의 배포 가능한 최소 단위
   - 하나 이상의 컨테이너를 포함
 2. 특징
   - 동일 Pod 내 컨테이너는 IP/Port/Volume 공유
   - Pod 자체는 휘발성
   - 실무에서는 통상 Pod는 직접 만들지 않음. Deployment, StatefulSet, Job등 논리 Unit으로 관리.
```
   
- Cluster > Namespace
```text
 1. 정의
   - 하나의 클러스터 내에서 리소스를 논리적으로 분리하는 공간
 2. 특징
   - 리소스 이름 충돌 방지
   - RBAC 권한 관리 단위
   - 환경 분리(dev/stage/prod)
 3. 기본 Namespace
   - default
   - kube-system
   - kube-public
   - kube-node-lease
```
 
- Cluster > Namespace > Deployment
```text
 1. 정의
   - Pod가 관리되는 상위객체
   - *가장 많이 사용*
 2. 특징
   - Pod의 배포 / 업데이트 / 롤백 관리
```

- Cluster > Namespace > Service
```text
 1. 정의
   - 변하는 Pod를 고정된 네트워크 주소로 묶는 객체
   - Pod 접근 창구
 2. 필요성
   - Pod는 재시작 시 IP가 변경됨. Service는 고정 IP/DNS 제공.
```
- Cluster > Namespace > ConfigMap / Secret (설정 관리)
```text
 1. 정의
   - Pod에 대한 설정 관리 객체
   - ConfigMap은 plain text 용 환경설정, Secret은 민감정보(Base64 인코딩)용 환경설정.
```

---

## 6. 주요 Kubectl 명령어

### 6.1 조회 관련 명령

- 노드/클러스터/파드 등의 현재 상태를 조회

```bash
kubectl config view                      # 설정 정보 확인
kubectl cluster-info                     # 클러스터 정보 확인
kubectl get namespaces                   # 네임스페이스 리스트 확인
kubectl get nodes                        # 노드정보 확인
kubectl get deployment                   # 디플로이 확인
kubectl get svc <svc-name> yaml          # 서비스 확인, 기본적으로 네임스페이스 명시 안하면 default를 조회. yaml 형식으로 덤프.
kubectl get svc -A                       # 서비스 확인, -A 옵션은 모든 네임스페이스를 조회
kubectl get svc -n <svc-name>            # 서비스 확인, 네임스페이스 명시
kubectl get pods                         # 파드 확인
kubectl get po                           # 파드 확인
kubectl get po -o wide                   # 상세 정보 포함
kubectl get po -n <namespace-name>       # 특정 네임스페이스의 파드 리스트 확인
kubectl describe po <pod-name> -n <namespace-name> # 상세 조회
kubectl get ep                           # 엔드포인트 확인
kubectl get all -n <name>                # 노드,서비스,파드 등 모든 정보 확인
```

### 6.2 등록/수정/삭제 관련 명령

- Deployment 관련 작업 명령

```bash
kubectl create namespace <new-namespace> # 네임스페이스 생성
kubectl create ns <new-namespace>        # 네임스페이스 생성
kubectl delete namespace <new-namespace> # 네임스페이스 삭제
kubectl delete ns <namespace-name>       # 네임스페이스 삭제
kubectl apply -f <yaml-file>             # 파드 생성/수정
kubectl delete -f <yaml-file>            # 파드 삭제
kubectl delete pod <pod-name> --grace-period=0 --force # 파드 강제 삭제
```

### 6.3 운영 관련 명령

- 운영 시 필요한 작업 명령

```bash
kubectl logs -f <pod-name> -n <ns>                  # 파드 로그 실시간 확인
kubectl exec -it <pod-name> /bin/bash               # 파드 원격 접속
kubectl cp /local/logs.txt <pod-name>:/opt/logs.txt # 파일 복사(로컬 to 파드)
kubectl cp <pod-name>:/opt/logs.txt ./logs.txt 	    # 파일 복사(파드 to 로컬)
```
