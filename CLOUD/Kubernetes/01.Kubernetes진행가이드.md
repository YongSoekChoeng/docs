[Dstone Document Index](../../Index.md)

# Kubernetes 클러스터 구축 가이드

이 문서는 VirtualBox와 Ubuntu 20.04를 사용하여 Kubernetes 클러스터(Master 1대, Worker 2대)를 구축하는 과정을 안내합니다.

---

## 1. 가상 환경 구성 (VirtualBox)

### 1.1. 사전 준비

-   **VirtualBox 설치**: [공식 사이트](https://www.virtualbox.org/wiki/Downloads)에서 최신 버전을 설치합니다.
-   **Ubuntu 20.04 ISO**: Ubuntu 20.04 LTS 데스크탑 이미지를 다운로드합니다.
-   **Hyper-V 설정 확인** : Windows에서 Hyper-V가 활성화되어 있는지 확인합니다.
    ```powershell
    bcdedit /enum | findstr /i hypervisorlaunchtype
    ```
-   **Hyper-V 비활성화**: 만약 결과가 `Off`가 아니라면, VirtualBox는 Windows의 Hyper-V와 충돌할 수 있습니다. 관리자 권한으로 다음 명령을 실행하여 비활성화합니다.
    ```powershell
    bcdedit /set hypervisorlaunchtype off
    ```
    > **참고:** WSL2나 Docker Desktop을 다시 사용하려면 `auto`로 재설정해야 합니다 (`bcdedit /set hypervisorlaunchtype auto`).

### 1.2. 가상 머신(VM) 생성

-   **Master Node**: `k8s-master` 이름으로 VM 생성
-   **Worker Node 1**: `k8s-node1` 이름으로 VM 생성
-   **Worker Node 2**: `k8s-node2` 이름으로 VM 생성

### 1.3. 네트워크 설정

1.  **NAT 네트워크 생성**
    -   VirtualBox `파일 > 도구 > 네트워크 관리자`에서 `만들기`를 클릭하여 NAT 네트워크를 생성합니다.
    -   네트워크 이름: `k8s-network`
    -   네트워크 CIDR: `10.100.0.0/16`

2.  **VM 네트워크 어댑터 설정**
    -   생성한 모든 VM(master, node1, node2)의 `설정 > 네트워크`에서 '다음에 연결됨'을 `NAT 네트워크`로 변경하고, 네트워크 이름으로 `k8s-network`를 선택합니다.

3.  **포트 포워딩 설정**
    -   `NAT 네트워크` 설정 화면의 `포트 포워딩` 버튼을 클릭하여 각 VM에 SSH로 접속할 수 있도록 규칙을 추가합니다.

| 이름        | 프로토콜 | 호스트 IP | 호스트 포트 | 게스트 IP      | 게스트 포트 |
| :---------- | :------- | :-------- | :---------- | :------------- | :---------- |
| k8s-master  | TCP      | 127.0.0.1 | 2200        | 10.100.0.100   | 22          |
| k8s-node1   | TCP      | 127.0.0.1 | 2201        | 10.100.0.101   | 22          |
| k8s-node2   | TCP      | 127.0.0.1 | 2202        | 10.100.0.102   | 22          |

---

## 2. 모든 노드 공통 설정

이제 각 VM에 접속하여 아래 설정을 **master, node1, node2에 모두 적용**합니다.

### 2.1. 호스트 이름 및 `hosts` 파일 설정

-   **/etc/hostname** 수정: 각 노드의 호스트 이름을 설정합니다.
    -   `k8s-master` 노드: `master`
    -   `k8s-node1` 노드: `node1`
    -   `k8s-node2` 노드: `node2`

-   **/etc/hosts** 수정: 모든 노드가 서로의 IP와 호스트 이름을 알 수 있도록 설정합니다.
    ```
    127.0.0.1       localhost
    10.100.0.100    master
    10.100.0.101    node1
    10.100.0.102    node2
    ```

### 2.2. 고정 IP 설정

-   `/etc/netplan/01-network-manager-all.yaml` 파일을 수정하여 고정 IP를 설정합니다. (파일명은 다를 수 있음)

    ```yaml
    network:
      version: 2
      renderer: NetworkManager
      ethernets:
        enp0s3: # 네트워크 인터페이스 이름 (ifconfig로 확인)
          dhcp4: no
          addresses:
            # master: [10.100.0.100/16]
            # node1: [10.100.0.101/16]
            # node2: [10.100.0.102/16]
            - 10.100.0.100/16
          routes:
            - to: default
              via: 10.100.0.1
          nameservers:
            addresses: [8.8.8.8, 8.8.4.4]
    ```

-   설정 적용
    ```bash
    sudo netplan apply
    ```

### 2.3. Kubernetes 사전 요구사항 설정

1.  **Swap 비활성화**
    ```bash
    sudo swapoff -a
    # 재부팅 후에도 적용되도록 /etc/fstab 파일에서 swap 라인을 주석 처리
    sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
    ```

2.  **필요 커널 모듈 로드**
    ```bash
    cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
    overlay
    br_netfilter
    EOF

    sudo modprobe overlay
    sudo modprobe br_netfilter
    ```

3.  **네트워크 브리지 설정**
    ```bash
    cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
    net.bridge.bridge-nf-call-iptables  = 1
    net.bridge.bridge-nf-call-ip6tables = 1
    net.ipv4.ip_forward                 = 1
    EOF

    # 변경사항 적용
    sudo sysctl --system
    ```

### 2.4. Docker 설치 (컨테이너 런타임)

Kubernetes는 컨테이너를 실행하기 위해 Docker와 같은 컨테이너 런타임이 필요합니다.

```bash
# 1. HTTPS 통신을 위한 패키지 설치
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl

# 2. Docker 공식 GPG 키 추가
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# 3. Docker 저장소 설정
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# 4. Docker Engine 설치
sudo apt-get update
sudo apt-get install -y docker-ce docker-ce-cli containerd.io

# 5. Cgroup 드라이버 설정
# containerd의 기본 설정 파일을 생성하고, SystemdCgroup을 true로 변경합니다.
sudo containerd config default | sudo tee /etc/containerd/config.toml
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml

# 6. 서비스 재시작
sudo systemctl restart containerd
sudo systemctl enable docker
```

### 2.5. Kubernetes 구성 요소 설치

`kubeadm`, `kubelet`, `kubectl`을 설치합니다.

```bash
# 1. apt 패키지 색인을 업데이트하고 HTTPS를 통해 저장소를 사용하는 데 필요한 패키지를 설치
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl gpg

# 2. Kubernetes 패키지 저장소의 공개 서명 키를 다운로드
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

# 3. Kubernetes apt 저장소를 추가
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

# 4. apt 패키지 색인을 업데이트하고 kubelet, kubeadm, kubectl을 설치하고 해당 버전을 고정
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl # 자동 업데이트 방지
```

### 2.6. Sftp 설치

---

## 3. Master Node 설정

**master 노드에서만** 다음 명령을 실행합니다.

### 3.1. 클러스터 초기화

```bash
# --pod-network-cidr: 파드 네트워크의 IP 주소 범위. Calico, Flannel 등 CNI 플러그인과 일치해야 함.
sudo kubeadm init --pod-network-cidr=10.244.0.0/16
```

### 3.2. kubectl 설정

-   초기화가 성공하면 출력되는 안내에 따라 `kubectl`을 설정합니다.
    ```bash
    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config
    ```

### 3.3. CNI(Container Network Interface) 플러그인 설치

-   파드 간의 통신을 위해 CNI 플러그인을 설치해야 합니다. 여기서는 **Flannel**을 사용합니다.
    ```bash
    kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
    ```

### 3.4. 클러스터 상태 확인

```bash
kubectl get nodes
# Master 노드가 'Ready' 상태로 표시되는지 확인합니다.
```

---

## 4. Worker Node 설정

**node1, node2에서 각각** 다음 명령을 실행합니다.

### 4.1. 클러스터에 조인

-   Master 노드에서 `kubeadm init` 실행 시 출력되었던 `kubeadm join` 명령어를 복사하여 실행합니다.
    ```bash
    sudo kubeadm join <master-ip>:6443 --token <token> --discovery-token-ca-cert-hash sha256:<hash>
    ```
-   만약 토큰을 잃어버렸다면, Master 노드에서 다음 명령으로 재생성할 수 있습니다.
    ```bash
    kubeadm token create --print-join-command
    ```

### 4.2. 조인 확인

-   다시 **Master 노드에서** `kubectl get nodes`를 실행하여 모든 Worker 노드가 `Ready` 상태가 되는지 확인합니다. (몇 분 정도 소요될 수 있습니다.)
    ```bash
    kubectl get nodes -o wide
    # NAME     STATUS   ROLES           AGE   VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME
    # master   Ready    control-plane   10m   v1.28.0   10.100.0.100   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   containerd://1.6.12
    # node1    Ready    <none>          2m    v1.28.0   10.100.0.101   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   containerd://1.6.12
    # node2    Ready    <none>          2m    v1.28.0   10.100.0.102   <none>        Ubuntu 20.04.5 LTS   5.15.0-52-generic   containerd://1.6.12
    ```

---

## 5. 주요 `kubectl` 명령어

| 작업 내용                    | 명령어                                       |
| :--------------------------- | :------------------------------------------- |
| 노드 목록 확인               | `kubectl get nodes -o wide`                  |
| 모든 네임스페이스의 파드 확인  | `kubectl get pods --all-namespaces`          |
| 특정 네임스페이스의 파드 확인  | `kubectl get pods -n <namespace>`            |
| 파드 상세 정보 확인          | `kubectl describe pod <pod-name> -n <ns>`    |
| 파드 로그 실시간 확인        | `kubectl logs -f <pod-name> -n <ns>`         |
| 파드 생성/수정               | `kubectl apply -f <yaml-file>`               |
| 파드 삭제                    | `kubectl delete -f <yaml-file>`              |
| 파드 강제 삭제               | `kubectl delete pod <pod-name> --grace-period=0 --force` |
| 네임스페이스 생성            | `kubectl create namespace <new-namespace>`   |